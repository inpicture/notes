<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Leaf Notes OS</title>
    
    <script src="https://cdn.tailwindcss.com"></script>
    <script>
        tailwind.config = {
            darkMode: 'class',
        }
    </script>
    <script crossorigin src="https://unpkg.com/react@18/umd/react.development.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>

    <style>
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600&display=swap');
        body { font-family: 'Inter', sans-serif; overflow: hidden; touch-action: none; background: #f8fafc; }

        /* --- DARK MODE --- */
        body.dark { background: #050505; color: #e5e5e5; }
        body.dark .dot-grid { background-image: radial-gradient(#404040 1.5px, transparent 1.5px); background-color: #050505; }
        body.dark .glass-panel { background: rgba(20, 20, 20, 0.9); border-color: rgba(255,255,255,0.08); color: #e5e5e5; }
        body.dark .glass-window { background: rgba(18, 18, 18, 0.96); border-color: rgba(255,255,255,0.08); color: #e5e5e5; }
        body.dark .glass-icon { background: rgba(30, 30, 30, 0.8); border-color: rgba(255,255,255,0.1); }
        body.dark input, body.dark textarea { background: #171717; color: #e5e5e5; border-color: #404040; }
        body.dark .text-slate-700 { color: #e5e5e5; }
        body.dark .text-slate-600 { color: #d4d4d4; }
        body.dark .text-slate-500 { color: #a3a3a3; }
        body.dark .text-slate-400 { color: #737373; }
        
        /* Dark Mode Map - Green Matrix Style */
        body.dark .leaflet-layer { filter: sepia(100%) hue-rotate(130deg) saturate(500%) contrast(1.2) brightness(1.4); }
        body.dark .toggle-active { background: #262626; color: #10b981; }

        /* --- 1. ENDLESS CANVAS (Normal Cursor) --- */
        .dot-grid {
            background-image: radial-gradient(#cbd5e1 1.5px, transparent 1.5px);
            background-size: 24px 24px;
            background-color: #f8fafc;
            cursor: default; /* NORMAL CURSOR */
        }

        /* --- 2. GLASS WINDOW --- */
        .glass-window {
            background: rgba(255, 255, 255, 0.95);
            backdrop-filter: blur(24px);
            -webkit-backdrop-filter: blur(24px);
            border: 1px solid rgba(255, 255, 255, 0.9);
            box-shadow: 0 20px 50px rgba(0, 0, 0, 0.15), 0 10px 20px rgba(0,0,0,0.05);
            border-radius: 12px;
            position: absolute;
            transform-origin: center center;
        }

        /* --- 3. SMOOTH CINEMATIC ANIMATIONS --- */
        
        /* Open: Fuze / Form Animation */
        @keyframes fuzeIn {
            0% { opacity: 0; transform: scale(0.85); filter: blur(12px); }
            100% { opacity: 1; transform: scale(1); filter: blur(0px); }
        }
        .animate-open { animation: fuzeIn 0.5s cubic-bezier(0.2, 0.8, 0.2, 1) forwards; }

        /* Close: Fade Out & Shrink (Reverse) */
        @keyframes gentleClose {
            0% { opacity: 1; transform: scale(1); }
            100% { opacity: 0; transform: scale(0.95); pointer-events: none; }
        }
        .animate-close { animation: gentleClose 0.2s ease-in forwards; }

        /* Icon: Simple Fade In */
        @keyframes iconFade {
            from { opacity: 0; } to { opacity: 1; }
        }
        .animate-icon { animation: iconFade 0.3s ease-out; }

        @keyframes popIn {
            0% { opacity: 0; transform: scale(0.9) translateX(20px); }
            100% { opacity: 1; transform: scale(1) translateX(0); }
        }
        .animate-pop-in { animation: popIn 0.4s cubic-bezier(0.175, 0.885, 0.32, 1.275) forwards; }

        .smooth-move { transition: left 0.05s linear, top 0.05s linear; }
        .dragging { transition: none !important; }

        /* --- 4. UI ELEMENTS --- */
        .glass-icon {
            background: rgba(255, 255, 255, 0.8);
            backdrop-filter: blur(12px);
            border: 1px solid rgba(255, 255, 255, 0.8);
            box-shadow: 0 4px 10px rgba(0, 0, 0, 0.05);
            transition: transform 0.2s ease, background 0.2s;
        }
        .glass-icon:hover {
            transform: scale(1.05);
            background: rgba(255, 255, 255, 0.95);
            box-shadow: 0 8px 20px rgba(0,0,0,0.1);
        }

        .glass-panel {
            background: rgba(255, 255, 255, 0.9);
            backdrop-filter: blur(24px);
            border: 1px solid rgba(255, 255, 255, 0.8);
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.08);
        }
        .suggestions-list {
            position: absolute; top: 110%; left: 0; width: 100%;
            background: rgba(255, 255, 255, 0.98);
            border-radius: 12px; border: 1px solid rgba(0,0,0,0.05);
            box-shadow: 0 10px 30px rgba(0,0,0,0.1);
            overflow: hidden; max-height: 200px; overflow-y: auto; z-index: 6000;
        }
        .suggestion-item { padding: 10px 16px; cursor: pointer; font-size: 13px; color: #475569; transition: background 0.1s; }
        .suggestion-item:hover { background: #f1f5f9; color: #0f172a; }

        .note-marker {
            background: #10b981; border: 2px solid white; border-radius: 50%;
            width: 14px; height: 14px; box-shadow: 0 0 0 4px rgba(16, 185, 129, 0.2);
            transition: all 0.2s ease; cursor: pointer;
            animation: markerSpread 0.5s cubic-bezier(0.34, 1.56, 0.64, 1);
        }
        @keyframes markerSpread {
            0% { transform: scale(0); opacity: 0; }
            60% { transform: scale(1.2); opacity: 1; }
            100% { transform: scale(1); opacity: 1; }
        }
        .note-marker:hover { transform: scale(1.5); background: #059669; z-index: 9999; }
        .note-marker.read { background: #94a3b8; box-shadow: 0 0 0 4px rgba(148, 163, 184, 0.2); }
        .note-marker.read:hover { background: #64748b; }

        .toggle-btn { transition: all 0.3s ease; }
        .toggle-active { background: white; color: #059669; box-shadow: 0 2px 8px rgba(0,0,0,0.05); }
        .toggle-inactive { background: transparent; color: #64748b; }
        
        #map-container { position: absolute; inset: 0; z-index: 0; opacity: 0; transition: opacity 0.6s ease; pointer-events: none; }
        .view-globe #map-container { opacity: 1; pointer-events: auto; }
        .view-globe .dot-grid { opacity: 0; pointer-events: none; }

        .notification-toast {
            position: absolute; top: 100px; left: 50%; transform: translateX(-50%);
            background: #0f172a; color: white; padding: 10px 20px; border-radius: 30px;
            font-size: 13px; font-weight: 500; z-index: 10000000; box-shadow: 0 10px 30px rgba(0,0,0,0.15);
            animation: slideDown 0.4s cubic-bezier(0.2, 0.8, 0.2, 1); pointer-events: none;
        }
        @keyframes slideDown { from { transform: translate(-50%, -40px); opacity: 0; } to { transform: translate(-50%, 0); opacity: 1; } }

        .cluster-marker {
            background: rgba(255, 255, 255, 0.9);
            border: 2px solid #10b981;
            color: #059669;
            border-radius: 50%;
            font-weight: 700;
            font-size: 12px;
            display: flex; align-items: center; justify-content: center;
            box-shadow: 0 4px 15px rgba(0,0,0,0.2);
            cursor: pointer; transition: transform 0.2s ease;
            animation: markerSpread 0.5s cubic-bezier(0.34, 1.56, 0.64, 1);
        }
        .cluster-marker:hover { transform: scale(1.15); background: #fff; z-index: 10000; }

        .avatar { width: 28px; height: 28px; border-radius: 50%; display: flex; align-items: center; justify-content: center; font-size: 16px; background: #f1f5f9; border: 2px solid #fff; box-shadow: 0 2px 5px rgba(0,0,0,0.1); object-fit: cover; }
        .avatar-lg { width: 64px; height: 64px; font-size: 32px; border-width: 4px; }
    </style>
</head>
<body>
    <div id="root"></div>

    <script type="text/babel">
        const { useState, useEffect, useRef, useMemo, useCallback } = React;

        // ICONS
        const IconPen = ({ size=20 }) => <svg width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2"><path d="M12 19l7-7 3 3-7 7-3-3z"></path><path d="M18 13l-1.5-7.5L2 2l3.5 14.5L13 18l5-5z"></path><circle cx="11" cy="11" r="2"></circle></svg>;
        const IconCheck = ({ size=20 }) => <svg width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2"><polyline points="20 6 9 17 4 12"></polyline></svg>;
        const IconX = ({ size=20 }) => <svg width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2"><line x1="18" y1="6" x2="6" y2="18"></line><line x1="6" y1="6" x2="18" y2="18"></line></svg>;
        const IconTrash = ({ size=20 }) => <svg width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2"><polyline points="3 6 5 6 21 6"></polyline><path d="M19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6m3 0V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2"></path></svg>;
        const IconShare = ({ size=20 }) => <svg width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2"><path d="M4 12v8a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2v-8"></path><polyline points="16 6 12 2 8 6"></polyline><line x1="12" y1="2" x2="12" y2="15"></line></svg>;
        const IconFile = ({ className="" }) => <svg width="28" height="28" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" className={className}><path d="M14 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V8z"></path><polyline points="14 2 14 8 20 8"></polyline><line x1="16" y1="13" x2="8" y2="13"></line><line x1="16" y1="17" x2="8" y2="17"></line><polyline points="10 9 9 9 8 9"></polyline></svg>;
        const IconSearch = () => <svg width="18" height="18" fill="none" stroke="currentColor" strokeWidth="2" viewBox="0 0 24 24"><circle cx="11" cy="11" r="8"></circle><line x1="21" y1="21" x2="16.65" y2="16.65"></line></svg>;
        const IconGrid = () => <svg width="16" height="16" fill="none" stroke="currentColor" strokeWidth="2" viewBox="0 0 24 24"><rect x="3" y="3" width="7" height="7"></rect><rect x="14" y="3" width="7" height="7"></rect><rect x="14" y="14" width="7" height="7"></rect><rect x="3" y="14" width="7" height="7"></rect></svg>;
        const IconGlobe = ({ size=16 }) => <svg width={size} height={size} fill="none" stroke="currentColor" strokeWidth="2" viewBox="0 0 24 24"><circle cx="12" cy="12" r="10"></circle><line x1="2" y1="12" x2="22" y2="12"></line><path d="M12 2a15.3 15.3 0 0 1 4 10 15.3 15.3 0 0 1-4 10 15.3 15.3 0 0 1-4-10 15.3 15.3 0 0 1 4-10z"></path></svg>;
        const IconLocation = () => <svg width="16" height="16" fill="none" stroke="currentColor" strokeWidth="2" viewBox="0 0 24 24"><path d="M21 10c0 7-9 13-9 13s-9-6-9-13a9 9 0 0 1 18 0z"></path><circle cx="12" cy="10" r="3"></circle></svg>;
        const IconCloud = () => <svg width="16" height="16" fill="none" stroke="currentColor" strokeWidth="2" viewBox="0 0 24 24"><path d="M18 10h-1.26A8 8 0 1 0 9 20h9a5 5 0 0 0 0-10z"></path></svg>;
        const IconUpload = ({ size=20 }) => <svg width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2"><path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"></path><polyline points="17 8 12 3 7 8"></polyline><line x1="12" y1="3" x2="12" y2="15"></line></svg>;
        const IconFlag = ({ size=20 }) => <svg width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2"><path d="M4 15s1-1 4-1 5 2 8 2 4-1 4-1V3s-1 1-4 1-5-2-8-2-4 1-4 1z"></path><line x1="4" y1="22" x2="4" y2="15"></line></svg>;
        const IconBell = ({ size=20 }) => <svg width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2"><path d="M6 8a6 6 0 0 1 12 0c0 7 3 9 3 9H3s3-2 3-9"></path><path d="M10.3 21a1.94 1.94 0 0 0 3.4 0"></path></svg>;
        const IconUser = ({ size=20 }) => <svg width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2"><path d="M20 21v-2a4 4 0 0 0-4-4H8a4 4 0 0 0-4 4v2"></path><circle cx="12" cy="7" r="4"></circle></svg>;
        const IconLogout = ({ size=20 }) => <svg width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2"><path d="M9 21H5a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h4"></path><polyline points="16 17 21 12 16 7"></polyline><line x1="21" y1="12" x2="9" y2="12"></line></svg>;
        const IconHeart = ({ size=20, fill=false }) => <svg width={size} height={size} viewBox="0 0 24 24" fill={fill ? "currentColor" : "none"} stroke="currentColor" strokeWidth="2"><path d="M20.84 4.61a5.5 5.5 0 0 0-7.78 0L12 5.67l-1.06-1.06a5.5 5.5 0 0 0-7.78 7.78l1.06 1.06L12 21.23l7.78-7.78 1.06-1.06a5.5 5.5 0 0 0 0-7.78z"></path></svg>;
        const IconBookmark = ({ size=20, fill=false }) => <svg width={size} height={size} viewBox="0 0 24 24" fill={fill ? "currentColor" : "none"} stroke="currentColor" strokeWidth="2"><path d="M19 21l-7-5-7 5V5a2 2 0 0 1 2-2h10a2 2 0 0 1 2 2z"></path></svg>;
        const IconMoon = ({ size=20 }) => <svg width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2"><path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path></svg>;

        const CITIES = {
            // Countries
            "Germany": [51.1657, 10.4515], "France": [46.2276, 2.2137], "United States": [37.0902, -95.7129],
            "United Kingdom": [55.3781, -3.4360], "Italy": [41.8719, 12.5674], "Spain": [40.4637, -3.7492],
            "Greece": [39.0742, 21.8243], "Japan": [36.2048, 138.2529], "China": [35.8617, 104.1954],
            "India": [20.5937, 78.9629], "Brazil": [-14.2350, -51.9253], "Australia": [-25.2744, 133.7751],
            "Canada": [56.1304, -106.3468], "Russia": [61.5240, 105.3188], "Egypt": [26.8206, 30.8025],
            "South Korea": [35.9078, 127.7669], "Turkey": [38.9637, 35.2433], "Mexico": [23.6345, -102.5528],
            "Indonesia": [-0.7893, 113.9213], "Netherlands": [52.1326, 5.2913], "Switzerland": [46.8182, 8.2275],
            "Sweden": [60.1282, 18.6435], "Poland": [51.9194, 19.1451], "Argentina": [-38.4161, -63.6167],
            
            // Major Cities
            "Athens, Greece": [37.9838, 23.7275], "Thessaloniki, Greece": [40.6401, 22.9444],
            "Cairo, Egypt": [30.0444, 31.2357], "London, UK": [51.5074, -0.1278],
            "Paris, France": [48.8566, 2.3522], "Rome, Italy": [41.9028, 12.4964],
            "New York, USA": [40.7128, -74.0060], "Tokyo, Japan": [35.6762, 139.6503],
            "Sydney, Australia": [-33.8688, 151.2093], "Rio de Janeiro, Brazil": [-22.9068, -43.1729],
            "Dubai, UAE": [25.2048, 55.2708], "Singapore": [1.3521, 103.8198],
            "Berlin, Germany": [52.5200, 13.4050], "Munich, Germany": [48.1351, 11.5820],
            "Hamburg, Germany": [53.5511, 9.9937], "Frankfurt, Germany": [50.1109, 8.6821],
            "Madrid, Spain": [40.4168, -3.7038], "Barcelona, Spain": [41.3851, 2.1734],
            "Moscow, Russia": [55.7558, 37.6173], "Beijing, China": [39.9042, 116.4074],
            "Shanghai, China": [31.2304, 121.4737], "Los Angeles, USA": [34.0522, -118.2437],
            "Chicago, USA": [41.8781, -87.6298], "San Francisco, USA": [37.7749, -122.4194],
            "Miami, USA": [25.7617, -80.1918], "Toronto, Canada": [43.6532, -79.3832],
            "Vancouver, Canada": [49.2827, -123.1207], "Istanbul, Turkey": [41.0082, 28.9784],
            "Mumbai, India": [19.0760, 72.8777], "Delhi, India": [28.7041, 77.1025],
            "Seoul, South Korea": [37.5665, 126.9780], "Mexico City, Mexico": [19.4326, -99.1332],
            "Jakarta, Indonesia": [-6.2088, 106.8456], "Bangkok, Thailand": [13.7563, 100.5018],
            "Buenos Aires, Argentina": [-34.6037, -58.3816], "Amsterdam, Netherlands": [52.3676, 4.9041],
            "Zurich, Switzerland": [47.3769, 8.5417], "Stockholm, Sweden": [59.3293, 18.0686],
            "Warsaw, Poland": [52.2297, 21.0122], "Vienna, Austria": [48.2082, 16.3738]
        };

        const HEADER_HEIGHT = 130;

        // --- DESKTOP ICON (Green Graphic) ---
        const DesktopIcon = ({ note, viewMode, canvasOffset, onOpen, onUpdate, onFocus, zIndex, isRead }) => {
            const [localPos, setLocalPos] = useState({ x: 0, y: 0 });
            const [isDragging, setIsDragging] = useState(false);

            useEffect(() => {
                if(!isDragging) {
                    if (viewMode === 'HOME') setLocalPos({ x: note.canvasX + canvasOffset.x, y: note.canvasY + canvasOffset.y });
                    else setLocalPos({ x: note.screenX, y: note.screenY });
                }
            }, [note, canvasOffset, viewMode, isDragging]);

            const handleStart = (e) => {
                e.stopPropagation();
                onFocus(); // Layer Priority
                setIsDragging(true);
                
                const clientX = e.touches ? e.touches[0].clientX : e.clientX;
                const clientY = e.touches ? e.touches[0].clientY : e.clientY;
                const startX = clientX - localPos.x;
                const startY = clientY - localPos.y;
                const initialX = clientX;
                const initialY = clientY;
                let moved = false;

                const handleMove = (ev) => {
                    const cx = ev.touches ? ev.touches[0].clientX : ev.clientX;
                    const cy = ev.touches ? ev.touches[0].clientY : ev.clientY;
                    if (Math.abs(cx - initialX) > 5 || Math.abs(cy - initialY) > 5) moved = true;
                    if (moved) {
                        if (ev.cancelable) ev.preventDefault();
                        setLocalPos({ x: cx - startX, y: Math.max(HEADER_HEIGHT, cy - startY) });
                    }
                };

                const handleEnd = (ev) => {
                    setIsDragging(false);
                    if (moved) {
                        const cx = ev.changedTouches ? ev.changedTouches[0].clientX : ev.clientX;
                        const cy = ev.changedTouches ? ev.changedTouches[0].clientY : ev.clientY;
                        const finalX = cx - startX;
                        const finalY = Math.max(HEADER_HEIGHT, cy - startY);
                        if (viewMode === 'HOME') onUpdate(note.id, { canvasX: finalX - canvasOffset.x, canvasY: finalY - canvasOffset.y });
                        else onUpdate(note.id, { screenX: finalX, screenY: finalY });
                    } else {
                        onOpen(note.id); // Click to open
                    }
                    window.removeEventListener('mousemove', handleMove);
                    window.removeEventListener('mouseup', handleEnd);
                    window.removeEventListener('touchmove', handleMove);
                    window.removeEventListener('touchend', handleEnd);
                };
                window.addEventListener('mousemove', handleMove);
                window.addEventListener('mouseup', handleEnd);
                window.addEventListener('touchmove', handleMove, { passive: false });
                window.addEventListener('touchend', handleEnd);
            };

            if (viewMode === 'GLOBE') return null;

            return (
                <div 
                    className={`absolute flex flex-col items-center gap-2 w-24 cursor-pointer group animate-icon ${isDragging ? 'dragging' : 'smooth-move'}`}
                    style={{ left: localPos.x, top: localPos.y, zIndex: zIndex }} 
                    onMouseDown={handleStart}
                    onTouchStart={handleStart}
                >
                    <div className={`w-16 h-20 glass-icon rounded-lg flex flex-col items-center justify-center relative ${isRead ? 'grayscale opacity-80' : ''}`}>
                        <IconFile className={isRead ? "text-slate-400 mb-1" : "text-emerald-500 mb-1"} />
                        <div className={`w-8 h-0.5 rounded-full mb-1 ${isRead ? 'bg-slate-300' : 'bg-emerald-500/20'}`}></div>
                        <div className={`w-6 h-0.5 rounded-full ${isRead ? 'bg-slate-300' : 'bg-emerald-500/20'}`}></div>
                    </div>
                    <div className="bg-white/60 backdrop-blur-md px-2 py-0.5 rounded-md border border-white/50 shadow-sm max-w-[120px]">
                        <p className="text-[11px] font-medium text-slate-700 truncate text-center select-none leading-tight">{note.content ? note.content.substring(0, 10) + "..." : "Leaf Note"}</p>
                    </div>
                </div>
            );
        };

        // --- NOTE WINDOW (Smooth Animation) ---
        const NoteWindow = ({ note, isOwner, viewMode, canvasOffset, onMinimize, onDelete, onUpdate, onFocus, zIndex, onNotify, onViewProfile, isSaved, onToggleSave, isLiked, onToggleLike }) => {
            const [localPos, setLocalPos] = useState({ x: 0, y: 0 });
            const [isDragging, setIsDragging] = useState(false);
            const [isClosing, setIsClosing] = useState(false);

            useEffect(() => {
                if (!isDragging) {
                    if (viewMode === 'HOME') setLocalPos({ x: note.canvasX + canvasOffset.x, y: note.canvasY + canvasOffset.y });
                    else setLocalPos({ x: note.screenX, y: note.screenY });
                }
            }, [note, canvasOffset, viewMode, isDragging]);

            const handleDragStart = (e) => {
                if (e.target.closest('button') || e.target.closest('textarea')) return;
                e.stopPropagation();
                onFocus(); // Layer Priority
                setIsDragging(true);
                
                const clientX = e.touches ? e.touches[0].clientX : e.clientX;
                const clientY = e.touches ? e.touches[0].clientY : e.clientY;
                const startX = clientX - localPos.x;
                const startY = clientY - localPos.y;

                const handleMove = (ev) => {
                    const cx = ev.touches ? ev.touches[0].clientX : ev.clientX;
                    const cy = ev.touches ? ev.touches[0].clientY : ev.clientY;
                    if (ev.cancelable) ev.preventDefault();
                    setLocalPos({ x: cx - startX, y: Math.max(HEADER_HEIGHT, cy - startY) });
                };

                const handleUp = (ev) => {
                    setIsDragging(false);
                    const cx = ev.changedTouches ? ev.changedTouches[0].clientX : ev.clientX;
                    const cy = ev.changedTouches ? ev.changedTouches[0].clientY : ev.clientY;
                    const finalX = cx - startX;
                    const finalY = Math.max(HEADER_HEIGHT, cy - startY);
                    if (viewMode === 'HOME') onUpdate(note.id, { canvasX: finalX - canvasOffset.x, canvasY: finalY - canvasOffset.y });
                    else onUpdate(note.id, { screenX: finalX, screenY: finalY });
                    window.removeEventListener('mousemove', handleMove);
                    window.removeEventListener('mouseup', handleUp);
                    window.removeEventListener('touchmove', handleMove);
                    window.removeEventListener('touchend', handleUp);
                };
                window.addEventListener('mousemove', handleMove);
                window.addEventListener('mouseup', handleUp);
                window.addEventListener('touchmove', handleMove, { passive: false });
                window.addEventListener('touchend', handleUp);
            };

            const handleShare = async () => {
                let text = "";
                if (note.published) {
                    text = `I just published my note in InpictureNotes, view it here: https://inpicturenotes.netlify.app/\n\nLook at this note from ${note.locationName} in the InpictureNotes app!`;
                } else {
                    text = note.content;
                }

                if (navigator.share) try { await navigator.share({ title: 'InpictureNotes', text: text }); } catch (err) {}
                else { navigator.clipboard.writeText(text); onNotify("Link copied!"); }
            };

            const handleReport = () => {
                const current = note.reports || 0;
                onUpdate(note.id, { reports: current + 1 });
                onNotify("Reported. If this note receives 10 reports, it will fall.");
            };

            const triggerMinimize = (e) => {
                e.stopPropagation();
                setIsClosing(true);
            };

            if (note.minimized && !isClosing) return null; 

            return (
                <div 
                    className={`absolute flex flex-col glass-window ${isClosing ? 'animate-close' : 'animate-open'} ${isDragging ? 'dragging shadow-2xl' : 'smooth-move'} dark:shadow-black/50`}
                    style={{ left: localPos.x, top: localPos.y, width: '300px', height: '360px', zIndex: zIndex }}
                    onMouseDown={onFocus} 
                    onAnimationEnd={() => {
                        if (isClosing) {
                            onMinimize(note.id);
                            setIsClosing(false);
                        }
                    }}
                >
                    <div onMouseDown={handleDragStart} onTouchStart={handleDragStart} className="h-14 bg-white/50 dark:bg-white/5 border-b border-white/60 dark:border-white/10 flex items-center justify-between px-3 cursor-move select-none">
                        <div className="flex items-center gap-3 pl-1 text-slate-600">
                            <div className="cursor-pointer hover:scale-105 transition-transform" onClick={(e) => { e.stopPropagation(); onViewProfile(note); }} onMouseDown={e => e.stopPropagation()}>
                                {note.authorAvatar ? <div className="avatar">{note.authorAvatar}</div> : <IconPen size={14} className="text-indigo-500" />}
                            </div>
                            <div className="flex flex-col pointer-events-none">
                                {note.authorName && <span className="text-[10px] font-bold text-slate-700 dark:text-slate-200 leading-tight">{note.authorName}</span>}
                                <span className="text-[9px] font-medium uppercase text-slate-500/70 leading-tight">{note.locationName}</span>
                            </div>
                        </div>
                        <div className="flex items-center gap-1.5 pl-2">
                            {isOwner ? (
                                <>
                                    <div className="flex items-center gap-1 bg-white/40 px-2 py-1 rounded-full mr-1">
                                        <IconHeart size={12} fill={true} className="text-rose-500" />
                                        <span className="text-[10px] font-bold text-slate-600">{note.likes || 0}</span>
                                    </div>
                                    <button onClick={handleShare} className="p-1.5 hover:bg-indigo-100 text-slate-500 rounded"><IconShare size={14} /></button>
                                    <button onClick={() => onDelete(note.id)} className="p-1.5 hover:bg-rose-100 text-slate-500 rounded"><IconTrash size={14} /></button>
                                    {!note.published ? (
                                        <button onClick={() => { onUpdate(note.id, { published: true }); onNotify("Note published to the Globe!"); }} className="p-1.5 hover:bg-emerald-100 text-emerald-600 rounded" title="Publish to Globe"><IconUpload size={14} /></button>
                                    ) : (
                                        <div className="p-1.5 text-emerald-500" title="Published on Globe"><IconGlobe size={14} /></div>
                                    )}
                                </>
                            ) : (
                                <>
                                    <button onClick={() => onToggleLike(note.id)} className={`flex items-center gap-1 px-2 py-1 rounded-full transition-colors mr-1 ${isLiked ? 'bg-rose-100 text-rose-600' : 'bg-white/40 text-slate-500 hover:bg-rose-50 hover:text-rose-500'}`}>
                                        <IconHeart size={12} fill={isLiked} />
                                        <span className="text-[10px] font-bold">{note.likes || 0}</span>
                                    </button>
                                    <button onClick={() => onToggleSave(note.id)} className={`p-1.5 rounded transition-colors ${isSaved ? 'text-emerald-600 bg-emerald-50' : 'text-slate-400 hover:bg-emerald-50 hover:text-emerald-600'}`} title={isSaved ? "Unsave" : "Save"}><IconBookmark size={14} fill={isSaved} /></button>
                                    <button onClick={handleShare} className="p-1.5 hover:bg-indigo-100 text-slate-500 rounded"><IconShare size={14} /></button>
                                    <button onClick={handleReport} className="p-1.5 hover:bg-amber-100 text-amber-600 rounded" title="Report"><IconFlag size={14} /></button>
                                </>
                            )}
                            <button onClick={triggerMinimize} className="p-1.5 hover:bg-slate-200 text-slate-500 rounded"><IconX size={14} /></button>
                        </div>
                    </div>
                    <div className="flex-1 relative bg-white/30 dark:bg-black/20 overflow-hidden">
                        <textarea 
                            readOnly={!isOwner}
                            className="w-full h-full bg-transparent p-4 outline-none resize-none text-slate-700 dark:text-slate-200 placeholder-slate-400 text-sm leading-relaxed"
                            placeholder="Write something..."
                            value={note.content}
                            onChange={(e) => onUpdate(note.id, { content: e.target.value })}
                            onMouseDown={e => e.stopPropagation()}
                        />
                    </div>
                </div>
            );
        };

        const App = () => {
            const [view, setView] = useState('HOME');
            const [notification, setNotification] = useState(null);
            const notifTimeout = useRef(null);
            const [notifications, setNotifications] = useState([]);
            const [pendingFocus, setPendingFocus] = useState(null);
            const [showNotifList, setShowNotifList] = useState(false);
            const notifListTimer = useRef(null);
            const [ticker, setTicker] = useState(() => Date.now());
            const [zoomLevel, setZoomLevel] = useState(5);
            const [showAuth, setShowAuth] = useState(false);
            const [authMode, setAuthMode] = useState('LOGIN'); // LOGIN or SIGNUP
            const [showVerification, setShowVerification] = useState(false);
            const [verificationCode, setVerificationCode] = useState("");
            const [viewProfile, setViewProfile] = useState(null); // { name, avatar, id, isMe }
            const [profileTab, setProfileTab] = useState('NOTES'); // NOTES or SAVED
            const [isEditingName, setIsEditingName] = useState(false);
            const [editNameInput, setEditNameInput] = useState("");

            const [darkMode, setDarkMode] = useState(() => {
                try { return JSON.parse(localStorage.getItem('leaf_dark_mode')) || false; } catch { return false; }
            });

            const getCenterPos = () => ({
                screenX: window.innerWidth / 2 - 150 + (Math.random() * 100 - 50),
                screenY: window.innerHeight / 2 - 180 + (Math.random() * 100 - 50)
            });

            useEffect(() => {
                const timer = setInterval(() => setTicker(Date.now()), 1000);
                return () => clearInterval(timer);
            }, []);

            useEffect(() => {
                localStorage.setItem('leaf_dark_mode', JSON.stringify(darkMode));
                if (darkMode) {
                    document.body.classList.add('dark');
                    document.documentElement.classList.add('dark');
                } else {
                    document.body.classList.remove('dark');
                    document.documentElement.classList.remove('dark');
                }
            }, [darkMode]);

            const flashNotifications = () => {
                setShowNotifList(true);
                if (notifListTimer.current) clearTimeout(notifListTimer.current);
                notifListTimer.current = setTimeout(() => setShowNotifList(false), 6000);
            };

            const showNotification = (msg) => {
                if (window.innerWidth < 768) return;
                setNotification(msg);
                if (notifTimeout.current) clearTimeout(notifTimeout.current);
                notifTimeout.current = setTimeout(() => setNotification(null), 3000);
            };
            
            // --- IDENTITY & STATE ---
            const [userId] = useState(() => {
                let id = localStorage.getItem('leaf_user_id');
                if (!id) { id = Math.random().toString(36).slice(2); localStorage.setItem('leaf_user_id', id); }
                return id;
            });
            const [userAccount, setUserAccount] = useState(() => {
                try { return JSON.parse(localStorage.getItem('leaf_user_account')); } catch { return null; }
            });
            const [authInput, setAuthInput] = useState({ email: "", password: "", name: "", avatar: "ðŸŒ±" });
            const [authLoading, setAuthLoading] = useState(false);
            const [readNotes, setReadNotes] = useState(() => {
                try { return JSON.parse(localStorage.getItem('leaf_read_notes')) || []; } catch { return []; }
            });
            const [likedNotes, setLikedNotes] = useState(() => {
                try { return JSON.parse(localStorage.getItem('leaf_liked_notes')) || []; } catch { return []; }
            });

            // NOTES: Shared Data (Content, Lat, Lng, Owner)
            const [notes, setNotes] = useState(() => {
                try { return JSON.parse(localStorage.getItem('leaf_cached_notes')) || []; } catch { return []; }
            });
            // UI: Local Viewport State (Open/Closed, Window Position) - NOT SYNCED
            const [localUi, setLocalUi] = useState({});

            const [cloudUrl, setCloudUrl] = useState(() => localStorage.getItem('leaf_cloud_url') || "wss://leaf-notes-backend.thomasthanos111.workers.dev");
            const [isCloudConnected, setIsCloudConnected] = useState(false);
            const wsRef = useRef(null);

            const globalZ = useRef(1000);
            const nextZ = () => { globalZ.current += 1; return globalZ.current; };

            const [canvasOffset, setCanvasOffset] = useState({ x: 0, y: 0 });
            const [search, setSearch] = useState("");
            const [searchSuggestions, setSearchSuggestions] = useState([]);
            const [isSettingHome, setIsSettingHome] = useState(false);
            const [homeInput, setHomeInput] = useState("");
            const [homeSuggestions, setHomeSuggestions] = useState([]);
            const [homeLocation, setHomeLocation] = useState(() => {
                try { return JSON.parse(localStorage.getItem('leaf_home_loc')) || { name: "Athens, Greece", lat: 37.9838, lng: 23.7275 }; } catch { return { name: "Athens, Greece", lat: 37.9838, lng: 23.7275 }; }
            });

            const mapRef = useRef(null);
            const [mapReady, setMapReady] = useState(false);
            const markersRef = useRef({});

            useEffect(() => localStorage.setItem('leaf_cached_notes', JSON.stringify(notes)), [notes]);
            useEffect(() => localStorage.setItem('leaf_home_loc', JSON.stringify(homeLocation)), [homeLocation]);
            useEffect(() => localStorage.setItem('leaf_cloud_url', cloudUrl), [cloudUrl]);
            useEffect(() => localStorage.setItem('leaf_user_account', JSON.stringify(userAccount)), [userAccount]);
            useEffect(() => localStorage.setItem('leaf_read_notes', JSON.stringify(readNotes)), [readNotes]);
            useEffect(() => localStorage.setItem('leaf_liked_notes', JSON.stringify(likedNotes)), [likedNotes]);

            // --- WEBSOCKET CONNECTION ---
            useEffect(() => {
                if (!cloudUrl) return;
                if (wsRef.current) wsRef.current.close();

                try {
                    const ws = new WebSocket(cloudUrl);
                    ws.onopen = () => setIsCloudConnected(true);
                    ws.onclose = () => setIsCloudConnected(false);
                    ws.onmessage = (event) => {
                        const msg = JSON.parse(event.data);
                        if (msg.type === 'SYNC_ALL') {
                            setNotes(msg.notes);
                        } else if (msg.type === 'CREATE') {
                            setNotes(prev => [...prev, msg.note]);
                            if (msg.note.published && msg.note.ownerId !== userId) {
                                showNotification("One new note");
                                setNotifications(prev => [{ id: msg.note.id, time: Date.now(), read: false }, ...prev]);
                                flashNotifications();
                            }
                        } else if (msg.type === 'UPDATE') {
                            // Only update data, ignore UI fields if they arrive
                            setNotes(prev => prev.map(n => n.id === msg.id ? { ...n, ...msg.updates } : n));
                            if (msg.updates.published) {
                                showNotification("One new note");
                                setNotifications(prev => [{ id: msg.id, time: Date.now(), read: false }, ...prev]);
                                flashNotifications();
                            }
                        } else if (msg.type === 'DELETE') {
                            setNotes(prev => prev.filter(n => n.id !== msg.id));
                        }
                    };
                    wsRef.current = ws;
                } catch (e) {
                    console.error("WS Error", e);
                }
                return () => { if (wsRef.current) wsRef.current.close(); };
            }, [cloudUrl]);

            useEffect(() => {
                if (view === 'GLOBE' && mapReady && pendingFocus && mapRef.current) {
                    const note = notes.find(n => n.id === pendingFocus);
                    if (note) {
                        if (!readNotes.includes(note.id)) setReadNotes(prev => [...prev, note.id]);
                        mapRef.current.flyTo([note.lat, note.lng], 8, { duration: 2.2, easeLinearity: 0.2 });
                        setTimeout(() => {
                            updateNote(note.id, { minimized: false, zIndex: nextZ(), ...getCenterPos() });
                        }, 2400);
                    }
                    setPendingFocus(null);
                }
            }, [view, mapReady, pendingFocus, notes]);

            const handleNotificationClick = (id) => {
                const note = notes.find(n => n.id === id);
                if (!note) return;
                if (!readNotes.includes(id)) setReadNotes(prev => [...prev, id]);
                setNotifications(prev => prev.map(n => n.id === id ? { ...n, read: true } : n));
                if (view !== 'GLOBE') {
                    setPendingFocus(id);
                    setView('GLOBE');
                } else {
                    if (mapRef.current) {
                        mapRef.current.flyTo([note.lat, note.lng], 8, { duration: 2.2, easeLinearity: 0.2 });
                        setTimeout(() => {
                            updateNote(note.id, { minimized: false, zIndex: nextZ(), ...getCenterPos() });
                        }, 2400);
                    }
                }
            };

            const visibleNotes = useMemo(() => {
                // 1. Filter based on View
                let filtered = notes;
                if (view === 'HOME') {
                    // In HOME, only show MY notes
                    filtered = notes.filter(n => n.ownerId === userId);
                } else {
                    // GLOBE: Show published notes that haven't fallen
                    // AND are less than 30 days old (extended for visibility)
                    const now = Date.now();
                    const TIME_WINDOW = 86400000 * 30;
                    filtered = notes.filter(n => n.published && (n.reports || 0) < 10 && (now - n.id < TIME_WINDOW));
                }
                
                // 2. Merge with Local UI State (Viewport)
                return filtered.map(n => {
                    const ui = localUi[n.id] || {};
                    return {
                        ...n,
                        // UI state overrides or defaults
                        minimized: ui.minimized !== undefined ? ui.minimized : true, // Default closed
                        zIndex: ui.zIndex || 0,
                        screenX: ui.screenX || n.screenX || 100,
                        screenY: ui.screenY || n.screenY || 100
                    };
                });
            }, [notes, localUi, view, userId]);

            // Init Map
            useEffect(() => {
                if (view === 'GLOBE' && !mapRef.current) {
                    setTimeout(() => {
                        const map = L.map('map-container', { zoomControl: false, attributionControl: false }).setView([homeLocation.lat, homeLocation.lng], 5);
                        const tileUrl = darkMode 
                            ? 'https://{s}.basemaps.cartocdn.com/dark_all/{z}/{x}/{y}{r}.png' 
                            : 'https://{s}.basemaps.cartocdn.com/light_all/{z}/{x}/{y}{r}.png';
                        const layer = L.tileLayer(tileUrl, { noWrap: true }).addTo(map);
                        map.on('zoomend', () => setZoomLevel(map.getZoom()));
                        mapRef.current = map;
                        mapRef.current.layer = layer;
                        setMapReady(true);
                    }, 50);
                }
            }, [view, darkMode]); // Re-init if dark mode changes (simple approach)

            // Update tiles when dark mode changes without full re-init if possible
            useEffect(() => {
                if (mapRef.current && mapRef.current.layer) {
                    const tileUrl = darkMode 
                        ? 'https://{s}.basemaps.cartocdn.com/dark_all/{z}/{x}/{y}{r}.png' 
                        : 'https://{s}.basemaps.cartocdn.com/light_all/{z}/{x}/{y}{r}.png';
                    mapRef.current.layer.setUrl(tileUrl);
                }
            }, [darkMode]);

            // Sync Markers (Only for Globe View)
            useEffect(() => {
                if (view === 'GLOBE' && mapRef.current) {
                    const map = mapRef.current;
                    const validMarkerIds = new Set();
                    
                    // Clear old markers not in use (simple approach: clear all and redraw for clustering simplicity or track them)
                    // For clustering, it's easier to clear layer group. But we have markersRef.
                    // Let's do a full redraw strategy for simplicity when clustering changes.
                    Object.values(markersRef.current).forEach(m => m.remove());
                    markersRef.current = {};

                    const toRender = [];
                    visibleNotes.forEach(note => {
                        if (note.content && note.content.trim() !== "") toRender.push(note);
                    });

                    // Clustering Logic
                    const clusters = [];
                    const processed = new Set();
                    const CLUSTER_RADIUS = zoomLevel < 9 ? 1.5 : 0.0001; // Degrees

                    toRender.forEach(note => {
                        if (processed.has(note.id)) return;
                        
                        const cluster = [note];
                        processed.add(note.id);

                        if (zoomLevel < 9) {
                            toRender.forEach(other => {
                                if (!processed.has(other.id)) {
                                    const d = Math.sqrt(Math.pow(note.lat - other.lat, 2) + Math.pow(note.lng - other.lng, 2));
                                    if (d < CLUSTER_RADIUS) {
                                        cluster.push(other);
                                        processed.add(other.id);
                                    }
                                }
                            });
                        }
                        clusters.push(cluster);
                    });

                    clusters.forEach(cluster => {
                        if (cluster.length > 1) {
                            // Render Cluster
                            const lat = cluster.reduce((sum, n) => sum + n.lat, 0) / cluster.length;
                            const lng = cluster.reduce((sum, n) => sum + n.lng, 0) / cluster.length;
                            const hasUnread = cluster.some(n => !readNotes.includes(n.id));
                            const icon = L.divIcon({ className: 'custom-div-icon', html: `<div class="cluster-marker" style="width:30px;height:30px;">${cluster.length}</div>`, iconSize: [30, 30], iconAnchor: [15, 15] });
                            const marker = L.marker([lat, lng], { icon }).addTo(map);
                            marker.on('click', () => {
                                const bounds = L.latLngBounds(cluster.map(n => [n.lat, n.lng]));
                                map.flyToBounds(bounds, { padding: [50, 50], maxZoom: 12, duration: 1.8, easeLinearity: 0.2 });
                            });
                            markersRef.current[`c_${lat}_${lng}`] = marker;
                        } else {
                            // Render Single
                            const note = cluster[0];
                            const isRead = readNotes.includes(note.id);
                            const icon = L.divIcon({ className: 'custom-div-icon', html: `<div class="note-marker ${isRead ? 'read' : ''}"></div>`, iconSize: [14, 14], iconAnchor: [7, 7] });
                            const marker = L.marker([note.lat, note.lng], { icon }).addTo(map);
                            marker.on('click', () => {
                                if (!readNotes.includes(note.id)) setReadNotes(prev => [...prev, note.id]);
                                updateNote(note.id, { minimized: false, zIndex: nextZ(), ...getCenterPos() }); 
                                map.flyTo([note.lat, note.lng], Math.max(map.getZoom(), 8), { duration: 2.2, easeLinearity: 0.2 });
                            });
                            markersRef.current[note.id] = marker;
                        }
                    });
                }
            }, [visibleNotes, view, mapReady, zoomLevel, readNotes]);

            const bringToFront = (id) => {
                updateNote(id, { zIndex: nextZ() });
            };

            useEffect(() => {
                // Auto-delete fallen notes if I own them
                notes.forEach(n => {
                    if (n.ownerId === userId && (n.reports || 0) >= 10) deleteNote(n.id);
                });
            }, [notes]);

            const createNote = (x, y, lat, lng, source) => {
                const startY = Math.max(HEADER_HEIGHT + 20, y);
                const finalLat = source === 'HOME' ? (homeLocation.lat + (Math.random() * 0.05)) : lat; 
                const finalLng = source === 'HOME' ? (homeLocation.lng + (Math.random() * 0.05)) : lng;
                const locName = source === 'HOME' ? homeLocation.name : "Map Location";

                const newNote = {
                    id: Date.now(),
                    ownerId: userId, // Mark as mine
                    content: "",
                    canvasX: source === 'HOME' ? (x - canvasOffset.x) : 0,
                    canvasY: source === 'HOME' ? (startY - canvasOffset.y) : 0,
                    // Initial default positions for data
                    screenX: x - 150,
                    screenY: startY - 180,
                    lat: finalLat, lng: finalLng, locationName: locName,
                    authorName: userAccount ? userAccount.name : "Anonymous",
                    authorAvatar: userAccount ? userAccount.avatar : "ðŸ‘¤",
                    history: [],
                    published: false, reports: 0, likes: 0
                };

                // Open locally immediately
                setLocalUi(prev => ({
                    ...prev,
                    [newNote.id]: { minimized: false, zIndex: nextZ(), screenX: newNote.screenX, screenY: newNote.screenY }
                }));

                setNotes(prev => [...prev, newNote]);

                if (wsRef.current && wsRef.current.readyState === 1) {
                    wsRef.current.send(JSON.stringify({ type: 'CREATE', note: newNote }));
                }
            };

            const updateNote = (id, updates) => {
                const UI_KEYS = ['minimized', 'zIndex', 'screenX', 'screenY'];
                const uiUpdates = {};
                const dataUpdates = {};
                
                Object.keys(updates).forEach(k => {
                    if (UI_KEYS.includes(k)) uiUpdates[k] = updates[k];
                    else dataUpdates[k] = updates[k];
                });

                // 1. Apply UI updates locally (Viewport)
                if (Object.keys(uiUpdates).length > 0) {
                    setLocalUi(prev => ({
                        ...prev,
                        [id]: { ...(prev[id] || {}), ...uiUpdates }
                    }));
                }

                // 2. Apply Data updates globally & sync
                if (Object.keys(dataUpdates).length > 0) {
                    setNotes(prev => prev.map(n => n.id === id ? { ...n, ...dataUpdates } : n));
                    if (wsRef.current && wsRef.current.readyState === 1) {
                        wsRef.current.send(JSON.stringify({ type: 'UPDATE', id, updates: dataUpdates }));
                    }
                }
            };

            const deleteNote = (id) => {
                setNotes(prev => prev.filter(n => n.id !== id));
                setLocalUi(prev => { const next = { ...prev }; delete next[id]; return next; });

                if (wsRef.current && wsRef.current.readyState === 1) {
                    wsRef.current.send(JSON.stringify({ type: 'DELETE', id }));
                }
            };

            const handleCanvasClick = (e) => {
                if (e.target.closest('.glass-window') || e.target.closest('.group') || e.target.closest('.ui-layer') || e.target.closest('button')) return;
                if (e.clientY < HEADER_HEIGHT) return;
                createNote(e.clientX, e.clientY, 0, 0, 'HOME');
            };

            const allLocations = useMemo(() => {
                const locs = new Set();
                // Prioritize locations from recent notes
                [...notes].reverse().forEach(n => { if(n.locationName) locs.add(n.locationName); });
                // Add static cities
                Object.keys(CITIES).forEach(c => locs.add(c));
                return Array.from(locs);
            }, [notes]);

            const handleSearchChange = (e) => {
                const val = e.target.value; setSearch(val);
                if (val.length > 0) setSearchSuggestions(allLocations.filter(c => c.toLowerCase().includes(val.toLowerCase())));
                else setSearchSuggestions([]);
            };
            
            const handleSearchFocus = () => {
                if (!search) setSearchSuggestions(allLocations.slice(0, 8)); // Show top 8 recent/popular
            };

            const selectCitySearch = (cityName) => {
                setSearch(cityName); setSearchSuggestions([]); setView('GLOBE');
                
                // Check if it's a known static city
                if (CITIES[cityName] && mapRef.current) {
                    mapRef.current.flyTo(CITIES[cityName], 6, {duration: 2.2, easeLinearity: 0.2});
                } else {
                    // Try to find a note with this location
                    const targetNote = notes.find(n => n.locationName === cityName);
                    if (targetNote && mapRef.current) {
                        mapRef.current.flyTo([targetNote.lat, targetNote.lng], 6, {duration: 2.2, easeLinearity: 0.2});
                    }
                }
            };

            const handleLogout = () => {
                setUserAccount(null);
                localStorage.removeItem('leaf_user_account');
                setViewProfile(null);
                showNotification("Logged out successfully");
            };

            const toggleSaveNote = async (noteId) => {
                if (!userAccount) {
                    setShowAuth(true);
                    showNotification("Please login to save notes");
                    return;
                }
                const saved = userAccount.saved || [];
                let newSaved;
                if (saved.includes(noteId)) {
                    newSaved = saved.filter(id => id !== noteId);
                    showNotification("Note removed from saved");
                } else {
                    newSaved = [...saved, noteId];
                    showNotification("Note saved to profile!");
                }
                const updatedUser = { ...userAccount, saved: newSaved };
                setUserAccount(updatedUser);
                // In a real app, sync this to backend via fetch('/auth/update', ...)
                // For now, local state + localStorage is enough for the demo feel
            };

            const toggleLikeNote = (noteId) => {
                const isLiked = likedNotes.includes(noteId);
                const note = notes.find(n => n.id === noteId);
                if (!note) return;

                const newLikes = (note.likes || 0) + (isLiked ? -1 : 1);
                updateNote(noteId, { likes: Math.max(0, newLikes) });

                if (isLiked) setLikedNotes(prev => prev.filter(id => id !== noteId));
                else setLikedNotes(prev => [...prev, noteId]);
            };

            const handleAuthSubmit = async () => {
                if (!authInput.email || !authInput.password) return;
                setAuthLoading(true);
                
                const httpUrl = cloudUrl.replace('wss://', 'https://');
                
                try {
                    if (showVerification) {
                        // VERIFY CODE
                        const res = await fetch(`${httpUrl}/auth/verify`, {
                            method: 'POST', body: JSON.stringify({ email: authInput.email, code: verificationCode })
                        });
                        const data = await res.json();
                        if (data.success) {
                            setUserAccount(data.user);
                            setShowAuth(false);
                            setShowVerification(false);
                            setVerificationCode("");
                            setAuthInput({ email: "", password: "", name: "", avatar: "ðŸŒ±" });
                            showNotification("Account verified & logged in!");
                        } else {
                            showNotification(data.error || "Verification failed");
                        }
                    } else if (authMode === 'SIGNUP') {
                        // SIGN UP
                        const res = await fetch(`${httpUrl}/auth/signup`, {
                            method: 'POST', body: JSON.stringify(authInput)
                        });
                        const data = await res.json();
                        if (data.success) {
                            setShowVerification(true);
                            // DEMO: Show code in notification because we can't send real emails
                            showNotification(`Code sent! (Demo: ${data.debug_code})`); 
                        } else {
                            showNotification(data.error || "Signup failed");
                        }
                    } else {
                        // LOGIN
                        const res = await fetch(`${httpUrl}/auth/login`, {
                            method: 'POST', body: JSON.stringify(authInput)
                        });
                        const data = await res.json();
                        if (data.success) {
                            setUserAccount(data.user);
                            setShowAuth(false);
                            setAuthInput({ email: "", password: "", name: "", avatar: "ðŸŒ±" });
                            showNotification("Welcome back!");
                        } else {
                            showNotification(data.error || "Login failed");
                        }
                    }
                } catch (e) {
                    console.error(e);
                    // FALLBACK FOR DEMO (If backend not deployed)
                    if (authMode === 'SIGNUP') {
                        setShowVerification(true);
                        showNotification("Code sent! (Demo: 123456)");
                        window.tempUser = { ...authInput, code: '123456' };
                    } else if (showVerification) {
                        if (verificationCode === '123456' && window.tempUser) {
                            const u = { email: window.tempUser.email, name: window.tempUser.name, avatar: window.tempUser.avatar, saved: [] };
                            setUserAccount(u);
                            setShowAuth(false);
                            setShowVerification(false);
                            showNotification("Account verified (Offline Demo)");
                        } else {
                            showNotification("Invalid code");
                        }
                    } else {
                        // Login fallback
                        const u = { email: authInput.email, name: "Demo User", avatar: "ðŸŒ±", saved: [] };
                        setUserAccount(u);
                        setShowAuth(false);
                        showNotification("Logged in (Offline Demo)");
                    }
                }
                setAuthLoading(false);
            };

            const handleHomeChange = (e) => {
                const val = e.target.value; setHomeInput(val);
                if (val.length > 1) setHomeSuggestions(Object.keys(CITIES).filter(c => c.toLowerCase().includes(val.toLowerCase())));
                else setHomeSuggestions([]);
            };
            const selectHomeCity = (cityName) => {
                const coords = CITIES[cityName];
                setHomeLocation({ name: cityName, lat: coords[0], lng: coords[1] });
                setHomeInput(""); setHomeSuggestions([]); setIsSettingHome(false);
            };

            const handleUpdateProfile = async () => {
                if (!editNameInput.trim() || !userAccount) return;
                const httpUrl = cloudUrl.replace('wss://', 'https://');
                try {
                    const res = await fetch(`${httpUrl}/auth/update`, {
                        method: 'POST',
                        body: JSON.stringify({ email: userAccount.email, updates: { name: editNameInput } })
                    });
                    const data = await res.json();
                    if (data.success) {
                        const updated = { ...userAccount, name: editNameInput };
                        setUserAccount(updated);
                        setViewProfile(prev => ({ ...prev, name: editNameInput }));
                        setIsEditingName(false);
                        showNotification("Profile name updated!");
                    } else { showNotification(data.error || "Update failed"); }
                } catch (e) {
                    const updated = { ...userAccount, name: editNameInput };
                    setUserAccount(updated);
                    setViewProfile(prev => ({ ...prev, name: editNameInput }));
                    setIsEditingName(false);
                    showNotification("Profile updated (Offline)");
                }
            };

            const openProfile = (note) => {
                const isMe = note ? note.ownerId === userId : true;
                const profileData = note ? {
                    id: note.ownerId, name: note.authorName || "Anonymous", avatar: note.authorAvatar || "ðŸ‘¤", isMe
                } : {
                    id: userId, name: userAccount ? userAccount.name : "Guest", avatar: userAccount ? userAccount.avatar : "ðŸ‘¤", isMe: true, isGuest: !userAccount
                };
                setViewProfile(profileData);
                setProfileTab('NOTES');
            };

            return (
                <div className={`relative w-screen h-screen overflow-hidden ${view === 'GLOBE' ? 'view-globe' : ''}`}>
                    <div className="absolute inset-0 dot-grid" style={{ backgroundPosition: `${canvasOffset.x}px ${canvasOffset.y}px` }} onClick={handleCanvasClick}></div>
                    <div id="map-container"></div>

                    {notification && <div className="notification-toast">{notification}</div>}

                    <div className="absolute top-20 right-6 md:top-6 md:right-6 z-[5000] pointer-events-auto">
                        <button onClick={() => { setShowNotifList(!showNotifList); if(notifListTimer.current) clearTimeout(notifListTimer.current); }} className="glass-panel p-3 rounded-full hover:scale-105 transition-transform relative text-slate-600 shadow-lg">
                            <IconBell />
                            {notifications.some(n => !n.read) && <div className="absolute top-0 right-0 w-3 h-3 bg-rose-500 rounded-full border-2 border-white"></div>}
                        </button>
                    </div>

                    <div 
                        className={`absolute top-36 right-6 md:top-20 md:right-6 z-[5000] pointer-events-auto transition-all duration-300 origin-top-right ${showNotifList ? 'opacity-100 scale-100' : 'opacity-0 scale-95 pointer-events-none'}`}
                        onMouseEnter={() => { if(notifListTimer.current) clearTimeout(notifListTimer.current); }}
                        onMouseLeave={() => { if(showNotifList) notifListTimer.current = setTimeout(() => setShowNotifList(false), 2000); }}
                    >
                        <div className="glass-panel rounded-2xl p-2 w-64 max-h-[60vh] overflow-y-auto shadow-2xl flex flex-col gap-1">
                            <div className="px-3 py-2 text-xs font-bold text-slate-400 uppercase tracking-wider border-b border-slate-100 mb-1">Notifications</div>
                            {notifications.length === 0 && <div className="p-4 text-center text-xs text-slate-400">No new notes.</div>}
                            {notifications.map(n => {
                                const note = notes.find(nt => nt.id === n.id);
                                if (!note) return null;
                                const seconds = Math.max(0, Math.floor((ticker - n.time) / 1000));
                                const timeStr = seconds < 60 ? `${seconds}s ago` : `${Math.floor(seconds/60)}m ago`;
                                return (
                                    <div key={n.id + "_" + n.time} onClick={() => handleNotificationClick(n.id)} className={`p-3 rounded-xl cursor-pointer hover:bg-slate-50 transition-colors flex items-center gap-3 border-l-2 ${n.read ? 'border-transparent opacity-60' : 'border-emerald-500 bg-emerald-50/30'}`}>
                                        <div className={`p-1.5 rounded-full ${n.read ? 'bg-slate-100 text-slate-400' : 'bg-emerald-100 text-emerald-600'}`}><IconGlobe size={14} /></div>
                                        <div className="flex flex-col">
                                            <span className={`text-xs ${n.read ? 'font-medium text-slate-600' : 'font-bold text-slate-800'}`}>New Note</span>
                                            <span className="text-[10px] text-slate-500 truncate w-32">{note.locationName}</span>
                                            <span className="text-[9px] text-slate-400 font-mono">{timeStr}</span>
                                        </div>
                                    </div>
                                );
                            })}
                        </div>
                    </div>

                    <div className="absolute top-20 left-6 md:top-8 md:left-6 z-[5000] pointer-events-auto">
                        <button onClick={() => openProfile(null)} className={`glass-panel p-2 rounded-full hover:scale-105 transition-transform flex items-center justify-center shadow-lg ${userAccount ? 'text-emerald-600' : 'text-slate-600'}`}>
                            {userAccount ? <div className="w-8 h-8 rounded-full bg-emerald-100 flex items-center justify-center text-lg border-2 border-white shadow-sm">{userAccount.avatar}</div> : <IconUser size={24} className="dark:text-white" />}
                        </button>
                    </div>

                    <div className="absolute top-0 left-0 w-full flex justify-center pt-4 md:pt-8 z-[5000] pointer-events-none ui-layer">
                        <div className="flex flex-col items-center gap-5 pointer-events-auto">
                            <div className="relative group w-[90%] max-w-xs sm:w-80">
                                <input type="text" placeholder="Search" className="glass-panel !bg-white dark:!bg-neutral-900/80 backdrop-blur-xl text-slate-700 dark:text-slate-200 placeholder-slate-500 pl-6 pr-11 py-3 rounded-full outline-none w-full font-medium tracking-wide transition-all focus:scale-105 focus:shadow-lg" value={search} onChange={handleSearchChange} />
                                <div className="absolute inset-y-0 right-4 flex items-center text-slate-500"><IconSearch /></div>
                                {searchSuggestions.length > 0 && (
                                    <div className="suggestions-list">
                                        {searchSuggestions.map(city => (<div key={city} className="suggestion-item" onClick={() => selectCitySearch(city)}>{city}</div>))}
                                    </div>
                                )}
                            </div>
                        </div>
                    </div>

                    <div className="absolute bottom-20 md:bottom-6 left-1/2 transform -translate-x-1/2 z-[5000] pointer-events-auto">
                        <div className="glass-panel rounded-full p-1.5 flex gap-1 shadow-2xl">
                            <button onClick={() => setView('HOME')} className={`flex items-center gap-2 px-6 py-2 rounded-full text-xs font-bold uppercase tracking-wide toggle-btn ${view === 'HOME' ? 'toggle-active' : 'toggle-inactive'}`}><IconGrid /> Home</button>
                            <button onClick={() => setView('GLOBE')} className={`flex items-center gap-2 px-6 py-2 rounded-full text-xs font-bold uppercase tracking-wide toggle-btn ${view === 'GLOBE' ? 'toggle-active' : 'toggle-inactive'}`}><IconGlobe /> Public</button>
                        </div>
                    </div>

                    {showAuth && (
                        <div className="absolute inset-0 z-[10000000] bg-black/40 backdrop-blur-sm flex items-center justify-center pointer-events-auto">
                            <div className="glass-panel p-6 rounded-2xl w-80 animate-pop-in shadow-2xl">
                                <div className="flex justify-between items-center mb-4">
                                    <h2 className="text-lg font-bold text-slate-700">{showVerification ? 'Verify Email' : (authMode === 'LOGIN' ? 'Welcome Back' : 'Join Leaf Notes')}</h2>
                                    <button onClick={() => setShowAuth(false)} className="text-slate-400 hover:text-slate-700"><IconX /></button>
                                </div>
                                
                                {!showVerification ? (
                                    <>
                                        <input type="email" placeholder="Email address" className="w-full bg-slate-50 border border-slate-200 rounded-lg px-3 py-2.5 text-sm outline-none focus:border-emerald-400 mb-3" value={authInput.email} onChange={e => setAuthInput({...authInput, email: e.target.value})} />
                                        {authMode === 'SIGNUP' && (
                                            <div className="mb-3 animate-slide-down">
                                                <input type="text" placeholder="Character Name" className="w-full bg-slate-50 border border-slate-200 rounded-lg px-3 py-2.5 text-sm outline-none focus:border-emerald-400 mb-3" value={authInput.name} onChange={e => setAuthInput({...authInput, name: e.target.value})} />
                                                <div className="flex justify-between gap-2">
                                                    {["ðŸŒ±","ðŸ¦Š","ðŸ¤–","ðŸ‘½","ðŸ±","ðŸ¶"].map(av => (
                                                        <button key={av} onClick={() => setAuthInput({...authInput, avatar: av})} className={`w-9 h-9 rounded-full flex items-center justify-center text-lg border-2 transition-all ${authInput.avatar === av ? 'border-emerald-500 bg-emerald-50 scale-110' : 'border-transparent hover:bg-slate-100'}`}>
                                                            {av}
                                                        </button>
                                                    ))}
                                                </div>
                                            </div>
                                        )}
                                        <input type="password" placeholder="Password" className="w-full bg-slate-50 border border-slate-200 rounded-lg px-3 py-2.5 text-sm outline-none focus:border-emerald-400 mb-4" value={authInput.password} onChange={e => setAuthInput({...authInput, password: e.target.value})} />
                                    </>
                                ) : (
                                    <input type="text" placeholder="Enter 6-digit code" className="w-full bg-slate-50 border border-slate-200 rounded-lg px-3 py-2.5 text-sm outline-none focus:border-emerald-400 mb-4 text-center tracking-widest font-mono" value={verificationCode} onChange={e => setVerificationCode(e.target.value)} />
                                )}

                                <button onClick={handleAuthSubmit} disabled={authLoading} className="w-full bg-emerald-500 hover:bg-emerald-600 text-white font-bold py-2.5 rounded-lg transition-colors mb-3 shadow-lg shadow-emerald-500/30 disabled:opacity-50">{authLoading ? 'Processing...' : (showVerification ? 'Verify Code' : (authMode === 'LOGIN' ? 'Log In' : 'Sign Up'))}</button>
                                <div className="text-center">
                                    {!showVerification && <button onClick={() => setAuthMode(authMode === 'LOGIN' ? 'SIGNUP' : 'LOGIN')} className="text-xs text-slate-500 hover:text-emerald-600 font-medium">{authMode === 'LOGIN' ? "Don't have an account? Sign up" : "Already have an account? Log in"}</button>}
                                    {showVerification && <button onClick={() => setShowVerification(false)} className="text-xs text-slate-500 hover:text-emerald-600 font-medium">Back</button>}
                                </div>
                            </div>
                        </div>
                    )}

                    {viewProfile && (
                        <div className="absolute inset-0 z-[6000] bg-black/30 backdrop-blur-sm flex items-center justify-center pointer-events-auto" onClick={() => setViewProfile(null)}>
                            <div className="glass-panel p-6 rounded-2xl w-80 animate-pop-in shadow-2xl flex flex-col items-center relative transition-all" onClick={e => e.stopPropagation()}>
                                <button onClick={() => { setViewProfile(null); setIsEditingName(false); }} className="absolute top-4 right-4 text-slate-400 hover:text-slate-700"><IconX /></button>
                                <div className="avatar avatar-lg mb-3">{viewProfile.avatar}</div>
                                
                                {viewProfile.isMe && isEditingName ? (
                                    <div className="flex items-center gap-2 mb-4">
                                        <input autoFocus type="text" className="bg-slate-100 border border-slate-300 rounded px-2 py-1 text-sm font-bold text-slate-800 w-40 outline-none focus:border-emerald-500" value={editNameInput} onChange={e => setEditNameInput(e.target.value)} onKeyDown={e => e.key === 'Enter' && handleUpdateProfile()} />
                                        <button onClick={handleUpdateProfile} className="p-1 bg-emerald-500 text-white rounded hover:bg-emerald-600"><IconCheck size={16}/></button>
                                        <button onClick={() => setIsEditingName(false)} className="p-1 bg-slate-200 text-slate-500 rounded hover:bg-slate-300"><IconX size={16}/></button>
                                    </div>
                                ) : (
                                    <div className="flex items-center gap-2 mb-4">
                                        <h2 className="text-xl font-bold text-slate-800">{viewProfile.name}</h2>
                                        {viewProfile.isMe && !viewProfile.isGuest && <button onClick={() => { setIsEditingName(true); setEditNameInput(viewProfile.name); }} className="text-slate-400 hover:text-emerald-600"><IconPen size={14} /></button>}
                                    </div>
                                )}
                                
                                {viewProfile.isMe && (
                                    <div className="w-full mb-4 bg-white dark:bg-neutral-800 rounded-xl p-3 border border-slate-100 dark:border-slate-700">
                                        <div className="flex justify-between items-center mb-1">
                                            <span className="text-[10px] font-bold text-slate-400 uppercase tracking-wider">Current Location</span>
                                            {!isSettingHome && <button onClick={() => setIsSettingHome(true)} className="text-xs text-indigo-500 font-bold hover:underline">Change</button>}
                                        </div>
                                        {!isSettingHome ? (
                                            <div className="flex items-center gap-2 text-slate-700 font-medium text-sm"><IconLocation size={14} className="text-indigo-500" />{homeLocation.name}</div>
                                        ) : (
                                            <div className="relative">
                                                <input autoFocus type="text" placeholder="City..." className="w-full bg-white border border-slate-200 rounded px-2 py-1 text-sm outline-none focus:border-indigo-500" value={homeInput} onChange={handleHomeChange} onBlur={() => setTimeout(() => setIsSettingHome(false), 200)} />
                                                {homeSuggestions.length > 0 && (
                                                    <div className="absolute top-full left-0 w-full bg-white border border-slate-100 rounded-lg shadow-xl mt-1 max-h-32 overflow-y-auto z-10">
                                                        {homeSuggestions.map(city => (<div key={city} className="px-3 py-2 text-xs text-slate-600 hover:bg-indigo-50 cursor-pointer" onMouseDown={() => selectHomeCity(city)}>{city}</div>))}
                                                    </div>
                                                )}
                                            </div>
                                        )}
                                    </div>
                                )}

                                {viewProfile.isMe && (
                                    <div className="w-full mb-4 flex items-center justify-between bg-white dark:bg-neutral-800 rounded-xl p-3 border border-slate-100 dark:border-slate-700">
                                        <span className="text-xs font-bold text-slate-600 dark:text-slate-300 flex items-center gap-2"><IconMoon size={14} /> Dark Mode</span>
                                        <button onClick={() => setDarkMode(!darkMode)} className={`w-10 h-5 rounded-full relative transition-colors ${darkMode ? 'bg-emerald-500' : 'bg-slate-300'}`}><div className={`absolute top-1 w-3 h-3 bg-white rounded-full transition-all ${darkMode ? 'left-6' : 'left-1'}`}></div></button>
                                    </div>
                                )}

                                <div className="w-full mb-4">
                                    <div className="flex border-b border-slate-200 mb-2">
                                        <button onClick={() => setProfileTab('NOTES')} className={`flex-1 pb-2 text-xs font-bold uppercase tracking-wide ${profileTab === 'NOTES' ? 'text-emerald-600 border-b-2 border-emerald-500' : 'text-slate-400'}`}>Notes</button>
                                        {viewProfile.isMe && <button onClick={() => setProfileTab('SAVED')} className={`flex-1 pb-2 text-xs font-bold uppercase tracking-wide ${profileTab === 'SAVED' ? 'text-emerald-600 border-b-2 border-emerald-500' : 'text-slate-400'}`}>Saved</button>}
                                    </div>
                                    
                                    <div className="max-h-32 overflow-y-auto flex flex-col gap-1">
                                        {profileTab === 'NOTES' && notes.filter(n => n.ownerId === viewProfile.id && n.published).length === 0 && <div className="text-xs text-slate-400 italic text-center py-2">No public notes yet.</div>}
                                        {profileTab === 'NOTES' && notes.filter(n => n.ownerId === viewProfile.id && n.published).map(n => (
                                            <div key={n.id} onClick={() => { setViewProfile(null); handleNotificationClick(n.id); }} className="text-xs p-2 bg-slate-50 rounded cursor-pointer hover:bg-emerald-50 truncate">{n.content || "Empty Note"}</div>
                                        ))}

                                        {profileTab === 'SAVED' && viewProfile.isMe && (!userAccount.saved || userAccount.saved.length === 0) && <div className="text-xs text-slate-400 italic text-center py-2">No saved notes.</div>}
                                        {profileTab === 'SAVED' && viewProfile.isMe && userAccount.saved && notes.filter(n => userAccount.saved.includes(n.id)).map(n => (
                                            <div key={n.id} onClick={() => { setViewProfile(null); handleNotificationClick(n.id); }} className="text-xs p-2 bg-slate-50 rounded cursor-pointer hover:bg-emerald-50 truncate">{n.content || "Empty Note"}</div>
                                        ))}
                                    </div>
                                </div>

                                {viewProfile.isMe && !viewProfile.isGuest && (
                                    <button onClick={handleLogout} className="w-full flex items-center justify-center gap-2 bg-rose-50 text-rose-600 hover:bg-rose-100 font-bold py-2 rounded-lg transition-colors text-xs">
                                        <IconLogout size={14} /> Log Out
                                    </button>
                                )}

                                {viewProfile.isGuest && (
                                    <button onClick={() => { setViewProfile(null); setShowAuth(true); }} className="w-full bg-emerald-500 hover:bg-emerald-600 text-white font-bold py-2 rounded-lg transition-colors text-xs shadow-lg shadow-emerald-500/30">
                                        Log In / Sign Up
                                    </button>
                                )}
                            </div>
                        </div>
                    )}

                    {visibleNotes.map(note => (
                        <React.Fragment key={note.id}>
                            <DesktopIcon 
                                note={note} viewMode={view} canvasOffset={canvasOffset}
                                onOpen={(id) => { updateNote(id, { minimized: false }); bringToFront(id); }}
                                isRead={readNotes.includes(note.id)}
                                onUpdate={updateNote}
                                onFocus={() => bringToFront(note.id)}
                                zIndex={note.zIndex}
                            />
                            <NoteWindow 
                                note={note} viewMode={view} canvasOffset={canvasOffset}
                                isOwner={note.ownerId === userId}
                                onMinimize={(id) => updateNote(id, { minimized: true })}
                                onDelete={deleteNote} onUpdate={updateNote}
                                onFocus={() => bringToFront(note.id)}
                                onNotify={showNotification}
                                onViewProfile={openProfile}
                                isSaved={userAccount && userAccount.saved && userAccount.saved.includes(note.id)}
                                onToggleSave={toggleSaveNote}
                                isLiked={likedNotes.includes(note.id)}
                                onToggleLike={toggleLikeNote}
                                zIndex={note.zIndex}
                            />
                        </React.Fragment>
                    ))}
                </div>
            );
        };

        const root = ReactDOM.createRoot(document.getElementById('root'));
        root.render(<App />);
    </script>
</body>
</html>
